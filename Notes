Variable Use Strictbecause of that when we declare var with variables it will enforce that var varible value can be changed witht he same variable name

without var we can declare variables 



var and let block scope vs function scope 

let variable can be intilized

String Indexing 
spaces are also included
.length function 

total elements & last index .length-1 

str.trim reomves spaces gives new string and first string is immutable

.toUpperCase  makes the string in Upper case
.toLowerCase make the string in Lower case
.slice method start index and end index not include end index like python [0:4]

typeof tells the datatype of the data

number to string 

age = age + "";

cosole.log(typeof age);

type casting 

let mystr = "34";

str to number

let mystr = +"34";

function
Number(mystr)

concatination 

let string1 = "saif";

let string2 = "hahah";


let fullName = string1 + " "+ string2 ;

convert to number 


let str1 = "17"

let str2= "14"

let newAdd = +str1 + +str2; answer 31


template string 

let Name = "Saif"

let Me = " my name is" + Name;

get rid of concatination 

back ticks ``

let age = 17
let Me = `my Name is ${Name} and my age is ${age}`

Undefined 

var or let firstName; variable made but no value then undefined and for constant you will have to give otherwise  error

print multiple things in console log 

console.log(first value, second value)

NULL

let myVariable = null;

object reference type null in typeof error in JavaScript

BigInt

let myNumber = 123;

console.log(myNumber, MAX_SAFE_INTEGER);

range of number can be store in Number data type

let myNumber = BigInt(12);
let myNumber = 123n; //same decalaration like above both are big int syntax is different 


u cannot add number with BigInt as both have there on operations

Booleans and Camparision 

<, >, >= , <=, true or false logical operators not and or xor odd 0 and 1 exor same 0,1


== just check value for type check also use === 

!= !==(type check)

falsy 

0 undefined false null empty string NaN

Truthy values other positve and negative value  

prompt() 

console.log(typeof variable, value variable)

Reference Types are object and store the address of the type memory store 
Heap more space stack will have address in stack 

and Primitive types non mutable imutable add  values to seprate location other than reference which stores address 
Stack less space

object literial 


array is mutable
 isArray
 
 push, pop (Fast), shift(remove element from begining)  and unshift (add element) 

array1=== array2

clone seprate array 

make arr1 and arr2 sperate 

arr1 = [1,2,3];

arr2 = [1,2,3];

more elenmts arr2 arr1.slice() speed good 

arr2 = [].concat(arr1);

spread operator 


let array2 = [...array1] good 

add and concate elemets 


arr1.slice(0).concat([1,2])

same for others

let array2 = [...array1,"items1"] arr 1 and more items into it 


let array2 = [...array1,...arr2] copies arrayies and concate

array.length  

const array cannot assign again you can do push,pop etc methods 

refernce type const 

for of loop 

fruits = [1,2,3]

for(let fruit(singular) of fruits(plural naming ){
console.log(fruit)
}
 
//values will be print untill last element


//in index 
for(let fruit(singular) in fruits(plural naming ){
console.log(fruit)
}

for of is mostly used 


Array Destructing 

for giving values to the variables from array 

const myArray = [1,2]

let [myvar1,myvar2] = myArray;

const [myvar1,myvar2] = myArray; //donot want to change 

skip index

let [myvar1,,myvar2] = myArray;

rest would be store in the myNewArray 
let [myvar1,myvar2,...myNewArray] = myArray;


Objects reference type  key pair value donot have indexes 

key should be unique 

object literal 
const person = {name:"saif",age:22}

access data from object

. access notation

add value 

person.gender = "male"

person["gender"] key is in string single or double quote 

person = {

"name" : sa,
}

same as above
person = {

name : sa,
}

for bracket notation "person hobbies"

person["person hobbies"]


let key = "saif"
person[key] = "hi"


iterate the objects 


object.keys and in 

for(let key in person){

console.log(person[key]);


console.log(`${key } ${person[key]}`);

console.log(key ,person[key]);

}



Objectkeys.keys(person) // returns array 

for(let key of Objects.keys(person)){

console.log(person[key])

}

computing properties

obj = {

[key1] : "",

[key2] :""
}

obj[key1] = value1;


SPREAD OPERATOR 

 
iterable string array

let newArray = [..."abc"]

same key would be overide with the last one key 


new object clone

newobj = {...obj1}

add key 

newobj = {...obj1,key22:"alue"}

newobject = {..."abc"}

newobject = {...["abc"]}

array to object or string to object 


Object Destructuing 

const band = {
bandName : "sa"

}

const {bandName} = band;


const {bandName:var2} = band;

const {bandName:var2,...restProps} = band;

objects inside arrays 

const users = [

{userId: 1, firstName:"saif" }


{userId: 2, firstName:"Asif" }

]


nested destruture 


const users = [

{userId: 1, firstName:"saif" }


{userId: 2, firstName:"Asif" }

]


const [user1,user2] = users

object destructure

const [{firstname},{username}] = users

const [{firstname: userFirstName,userId},{username: userGender}] = users


functions 

fnction saif(){

}

undefined + undefined = NaN 



function decalaration and function decalaration var assign declaration 

function sayHello(){
console.log("Hi");
}

const sayHello =  

function (){
console.log("Hi");
}

arrow function 
let sayHello = () =>{


}


one parameter 

let saif = number => {

}


one line

let saif = number => return console.log("saif")



Hoisting 

function call before  declaration not for function expression or arrow cannot for call



console.log(hello) undefined

hello = "saf"


console.log(hello) saf
var undefined 

let const error before 


call back function 

function inside function 

app = () => {

saif = () => {

 console.log(saif1111111);
}


console.log("saif")

saif();
}

lexical Scope envirnment 


Let,Const are block environment 

Var is function scope and main function var can be used in the file priority would be given the nearest scope

of same name

Default Parameters in functions

not pass second argument then it is undefined 

rest paramters array other parameters which are not parameter

saif(a,b,...c){

}

saif(1,2,3,4,5)


Array.isArray()
param destructing 

object usage
function Saif({firstname})
{}

saif(obj)

obj{
firdtname : "saif"
}


call back function 

myFunc2(){

console.log("function2")
}

myfunc1(callback){

callback();
}

myfunct1(myfunc2)



function returning function


function func(){

function hello(){

}

return hello;
}


ans = funct();

ans will contain hello functiin


higher function takes input and return function 


ARRAY Methods

forEach take index value and do some function  takes index and value of the array


numbers.forEach(function(number,index){

});




 

map new array and save in variable 
number.map() if no return is from call back function then it is undefined for each element 


filter condition and return an array which statisifes the condition true or false add value of true in the array  from callback 

reduce call baarray ck function return acummulator value and current value will be of cuurent array 
returns value 

Sort Method mutable string sort 

numbers.sort((a,b)=>{
return a-b

})

+ a,b greater than 0 

-ve b,a

descending b-a



find not find then undefiend 

every method returns ttue or false returns boolean when all elemts are true 

some method true if any condition is true 

fill add items 

myArray =  new Array(10).(0);


exisitng array fil value  start end 

mutable 
Slice 
start delete or insert 
mutable 

insert and delete together 

returns deleted items


Iterables for of loop 


Objects are not iterable 


Array like object lenght and access through index 


Set iterable ,no index based access no duplicates oreder is not done 

unique and no duplicate set return new eleemtns extract value 


MAP object 

object literial is keys in symbol and string 


const person = new Map()

key can be of any type set and get methods  and also keys method 

object in for in loop can be done

iterable for of loop 

u can get destructure in map order fashion not in object 

object assign Object.assign({},obj) 

optional chaining ?. undefined exits null or undefined not accesss it and stop nested object 

method inside object to get values of the object u can use this run ime 

this and window in the brower is the same 

your function will be added to the window

use strict then undefined

.call also function 

call,apply, bind

oen function can be callled with other using 

call then u bind with the object with the function 

u can pass arugumnets to

apply array u can pass arguments
 

blind function return just save that and call that thing it will call the function 

arrow function does not have this takes this from surronding 

cannot thing the this of arrow function one level above 

copy one object to the other use Object.create chain of protype and gives empty protoype also 


proto sees inside when something is not find it stores references 

___proto__, [[prototype]] are same

sets prottype chaining 

objects functions seprate and give reference to the object to reduce function definition more lines 

prototype is different 

PROTOTYPE

Function ===> Function + Object
FUNCTION are also object to u can treat 

u can also add properties add keypair value 

it gives us free space empty object protype 

It has constructor it gives us functions protype property 

function provides us useful properties 

add propertie and functions 


create connection between proto and protype 

protype object and proto chain reference 

New keyword 

create object which is empty this {} return this gives protype links the proto automatically  

Constructor function object new call with Capital word 

hasOwnProperty() tells his own property rather than protype 

Object.getPrototypeOf()

change protype just do .protype = [] 

Classes are fake cannot call the class without new 

Inheritance just use extends keyword 

super(name,age) takes properties of the parent class and gives it to the subclass 

get and setter just add get and set before the function name 

Static Properties and Methods

Static Class method and static properties common data 




 js Works
 
compile phase tokenizing lexing break code tokens, parsing abstract syntax tree excutable code AST and code generation

eARLY ERROR cHECKING

Determning APPROIATE Scope variable

not in function global scope 


Code Execution Phase Excute in Excution Context Global Exexution Text 

-creation Phase 
 Global Memory
 
this value in broswer other node js different 

-Code excution phase 

Java SIngle Thread and Synchrous Programming

Global Execution in Stack ,function will also be 

gLOABL eNVIRONEMNT code which also makes an object 


Hoisting MEMEORY store in Global Execution context 

Stack Pop from current GLobal excution context and current execution

In function expression undefined not on proper function declaration 

var function in function expression undefined 

GEC -> Creation - Global Memoery and Code Execution  

Let uninitilized there will be error same for const do hoisting  

Temporal Dead Zone uninitlized till initlized time duration for that is Temporal

not for const 


function Exceution Context new excecution context create local memoery creatation and code execute 

arguments like oject 

Closure function can return function 

return functions returns with it's local variables and it's name present returnns local variables lexical environment inner outer function he can access 

Async vs Defer 

Async Parse Javascript then parsing and Javascript file will parse together and js load file will excute then untill html is stopped 
defer parsing and loading together untill both are done

use defer excecute

DOM will make html tree in object in Window and store in it as a key pair

documents have object and also for style 

Set and get attribute

get elements by Id,Class name

forEach through for each html collection

node list u can use all loop

innerhtml and transverse 
Class List

getElementById live list

querySelectorAll static list

first capture bubling and then bubbling

event delegation from child to parent to grandparent event is delegated
