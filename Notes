Variable Use Strictbecause of that when we declare var with variables it will enforce that var varible value can be changed witht he same variable name

without var we can declare variables 



var and let block scope vs function scope 

let variable can be intilized

String Indexing 
spaces are also included
.length function 

total elements & last index .length-1 

str.trim reomves spaces gives new string and first string is immutable

.toUpperCase  makes the string in Upper case
.toLowerCase make the string in Lower case
.slice method start index and end index not include end index like python [0:4]

typeof tells the datatype of the data

number to string 

age = age + "";

cosole.log(typeof age);

type casting 

let mystr = "34";

str to number

let mystr = +"34";

function
Number(mystr)

concatination 

let string1 = "saif";

let string2 = "hahah";


let fullName = string1 + " "+ string2 ;

convert to number 


let str1 = "17"

let str2= "14"

let newAdd = +str1 + +str2; answer 31


template string 

let Name = "Saif"

let Me = " my name is" + Name;

get rid of concatination 

back ticks ``

let age = 17
let Me = `my Name is ${Name} and my age is ${age}`

Undefined 

var or let firstName; variable made but no value then undefined and for constant you will have to give otherwise  error

print multiple things in console log 

console.log(first value, second value)

NULL

let myVariable = null;

object reference type null in typeof error in JavaScript

BigInt

let myNumber = 123;

console.log(myNumber, MAX_SAFE_INTEGER);

range of number can be store in Number data type

let myNumber = BigInt(12);
let myNumber = 123n; //same decalaration like above both are big int syntax is different 


u cannot add number with BigInt as both have there on operations

Booleans and Camparision 

<, >, >= , <=, true or false logical operators not and or xor odd 0 and 1 exor same 0,1


== just check value for type check also use === 

!= !==(type check)

falsy 

0 undefined false null empty string NaN

Truthy values other positve and negative value  

prompt() 

console.log(typeof variable, value variable)

Reference Types are object and store the address of the type memory store 
Heap more space stack will have address in stack 

and Primitive types non mutable imutable add  values to seprate location other than reference which stores address 
Stack less space

object literial 


array is mutable
 isArray
 
 push, pop (Fast), shift(remove element from begining)  and unshift (add element) 

array1=== array2

clone seprate array 

make arr1 and arr2 sperate 

arr1 = [1,2,3];

arr2 = [1,2,3];

more elenmts arr2 arr1.slice() speed good 

arr2 = [].concat(arr1);

spread operator 


let array2 = [...array1] good 

add and concate elemets 


arr1.slice(0).concat([1,2])

same for others

let array2 = [...array1,"items1"] arr 1 and more items into it 


let array2 = [...array1,...arr2] copies arrayies and concate

array.length  

const array cannot assign again you can do push,pop etc methods 

refernce type const 

for of loop 

fruits = [1,2,3]

for(let fruit(singular) of fruits(plural naming ){
console.log(fruit)
}
 
//values will be print untill last element


//in index 
for(let fruit(singular) in fruits(plural naming ){
console.log(fruit)
}

for of is mostly used 


Array Destructing 

for giving values to the variables from array 

const myArray = [1,2]

let [myvar1,myvar2] = myArray;

const [myvar1,myvar2] = myArray; //donot want to change 

skip index

let [myvar1,,myvar2] = myArray;

rest would be store in the myNewArray 
let [myvar1,myvar2,...myNewArray] = myArray;


Objects reference type  key pair value donot have indexes 

key should be unique 

object literal 
const person = {name:"saif",age:22}

access data from object

. access notation

add value 

person.gender = "male"

person["gender"] key is in string single or double quote 

person = {

"name" : sa,
}

same as above
person = {

name : sa,
}

for bracket notation "person hobbies"

person["person hobbies"]


let key = "saif"
person[key] = "hi"


iterate the objects 


object.keys and in 

for(let key in person){

console.log(person[key]);


console.log(`${key } ${person[key]}`);

console.log(key ,person[key]);

}



Objectkeys.keys(person) // returns array 

for(let key of Objects.keys(person)){

console.log(person[key])

}

computing properties

obj = {

[key1] : "",

[key2] :""
}

obj[key1] = value1;


SPREAD OPERATOR 

 
iterable string array

let newArray = [..."abc"]

same key would be overide with the last one key 


new object clone

newobj = {...obj1}

add key 

newobj = {...obj1,key22:"alue"}

newobject = {..."abc"}

newobject = {...["abc"]}

array to object or string to object 


Object Destructuing 

const band = {
bandName : "sa"

}

const {bandName} = band;


const {bandName:var2} = band;

const {bandName:var2,...restProps} = band;

objects inside arrays 

const users = [

{userId: 1, firstName:"saif" }


{userId: 2, firstName:"Asif" }

]


nested destruture 


const users = [

{userId: 1, firstName:"saif" }


{userId: 2, firstName:"Asif" }

]


const [user1,user2] = users

object destructure

const [{firstname},{username}] = users

const [{firstname: userFirstName,userId},{username: userGender}] = users


functions 

fnction saif(){

}

undefined + undefined = NaN 



function decalaration and function decalaration var assign declaration 

function sayHello(){
console.log("Hi");
}

const sayHello =  

function (){
console.log("Hi");
}

arrow function 
let sayHello = () =>{


}


one parameter 

let saif = number => {

}


one line

let saif = number => return console.log("saif")



Hoisting 

function call before  declaration not for function expression or arrow cannot for call



console.log(hello) undefined

hello = "saf"


console.log(hello) saf
var undefined 

let const error before 


call back function 

function inside function 

app = () => {

saif = () => {

 console.log(saif1111111);
}


console.log("saif")

saif();
}




